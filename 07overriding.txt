
객체로는 속성과 기능이있다
클래스는 객체를 만들기 위한 청사진

int a=30; a를 일컬어서 int의 실제(Instance)라고 합니다.
그래서 객체를 인스턴스라고 부리기도 합니다.

클래스 안에 선언된 변수들을 일컬어 필드(Field)라고 합니다.
그리고 필드와 메소드를 비롯하여 프로퍼티, 이벤트 등의 클래스
내에 선언되어 있는 요소들을 일컬어 멤버(Member)라고 합니다.

Cat()은 생성자(Constructor)라고 하는 특별한 메소드입니다.
생성자는 클래스의 이름과 동일한 이름을 가지며, 객체를 생성하는 역할을 합니다.
Cat() 생성자 앞에 있는 new 키워드는 생성자를 호출해서 객체를 생성하는 데 사용하는 연산자

Cat 클래스를 비롯한 모든 클래스는 복합 데이터 형식입니다.
그리고 복합 데이터 형식은 참조 형식입니다.

7.4 정적 필드와 메소드
c#에서 static은 메소드나 필드가 클래스의 인스턴스가 아닌 클래스 자체에 소속되도록 지정하는 한정자입니다.

한 프로그램 안에서 인스턴스는 여러 개가 존재할 수 있으나 클래스는 단 하나만 존재합니다.
똑같은 클래스가 두 개 이상 존재한다는 것을 의미합니다.

프로그램 전체에 걸쳐 공유해야 하는 변수가 있다면 정적 필드를 이용하면 됩니다.

 ICloneable.Clone()메소드
(클래스가 구현해야 하는 메소드 목록)
"깊은 복사" 기능을 가질 클래스가 .Net 프레임워크의 다른 유틸리티 클래스나 다른 프로그래머가
작성한 코드와의 호환되도록 하고 싶다면 IClone을 상속하도록 하는 것이 좋습니다.
ICloneable 인터페이스는 Clone() 메소드 하나만 갖고 있습니다.

7.6 this 키워드
this는 객체가 자신을 지칭할 때 사용하는 키워드입니다.
이게 무슨 말인고 하니, 객체 외부에서는 객체의 필드나 메소드에 접근할 때 객체의이름(변수 또는 식별자)
객체 내부에서는 자신의 필드나 메소드에 접근할 때 this 키워드를 사용한다는 것입니다.

7.7 접근 한정자
public 클래스의 내부/외부 모든 곳에서 접근할 수 있습니다.
protected 클래스의 외부에서는 접근할 수 없지만, 파생 클래스에서는 접근이 가능합니다.
private 클래스의 내부에서만 접근할 수 있습니다. 파생 클래스에서도 접근이 불가능합니다.

internal 같은 어셈블리에 있는 코드에 대해서만 public으로 접근할 수 있습니다.
다른 어셈블리에 있는 코드에서는 private와 같은 수준의 접근성을 가집니다.

protected internal 같은 어셈블리에 있는 코드에 대해서만 protected로 접근할 수 있습니다.
다른 어셈블리에 있는 코드에서는 private와 같은 수준의 접근성을 가집니다.

7.8 상속으로 코드 재활용하기
객체 지향 프로그래밍에서는 물려받는 클래스(파생 클래스Derived Class) Ehsms 또는 자식 클래스라고 합니다.
this 키워드가 "자기 자신"을 가리킨다면 base는 "기반 클래스"를 가리킵니다.

7.12 오버라이딩 봉인하기
클래스를 (상속이 안 되도록) 봉인하는 것처럼 메소드도 (오버라이딩되지 않도록) 봉인할 수 있습니다.
그렇다고 모든 메소드를 봉인할 수 있는 것은 아니고,
virtual로 선언된 가상 메소드를 오버라이딩한 버전의 메소드만이 가능합니다.
예를 들어 다음과 같이 Base 클래스와 Derived 클래스가 있다고 하면, Derived의 SealMe()만 봉인할 수 있습니다.

7.15 확장 메소드
확장 메소드(Extension Method)는 기존 클래스의 기능을 확장하는 기법입니다.
기반 클래스를 물려받아 파생 클래스를 만든 뒤 여기에 필드나 메소드를 추가하는 상속과는 다릅니다.
다시 한번 이야기하지만, 확장 메소드는 "기존 클래스"의 기능을 확장합니다. 
확장 메소드를 이용하면 string 클래스에 문자열을 뒤집는 기능을 넣을 수도 있고,
int 형식에 제곱 연산 기능을 넣을 수도 있습니다.
확장 메소드를 선언하는 방법은 다음과 같습니다.
메소드를 선언하되, static 한정자로 수식해야 합니다.
그리고 이 메소드의 첫 번째 매개 변수는 반드시 this 키워드와 함께 확장하고자 하는 클래스(형식)의
인스턴스여야 합니다.
그 뒤에 따라오는 매개 변수 목록이 실제로 확장 메소드를 호출할 때 입력되는 매개 변수입니다.
메소드는 클래스 없이 선언될 수 없지요?
따라서 클래스를 하나 선언하고 그 안에 확장 메소드를 선언합니다.
이 때 선언하는 클래스도 역시 static 한정자로 수식해야 합니다.